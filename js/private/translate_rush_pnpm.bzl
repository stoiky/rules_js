"Convert package-lock.json into starlark Bazel fetches"

_DOC = """
"""

_ATTRS = {
    "rush_config": attr.label(
        doc = "The location of rush.json file.",
        mandatory = True,
    ),
    "pnpm_settings": attr.label(
        doc = "The location of pnpmfileSettings file.",
        mandatory = True,
    ),
}

_NPM_IMPORT_TMPL = """    # @generated from [translate_rush_pnpm.bzl]
    npm_import(
        name = "{name}",
        package = "{package}",
        version = "{version}",
    )
"""

def _escape(package_name):
    "Make a package name into a valid label without slash or at-sign"
    return package_name.replace("/", "_").replace("@", "_")

def _repo_name(package_name, version):
    "Make an external repository name from a package name and a version"
    return "npm_%s-%s" % (_escape(package_name), version)

def _parse_projects(projects, settings, bzl_out = None):
    # To allow recursion, accept an optional accumulator
    # If it's not present, we need to start with the header of the file
    bzl_out = bzl_out or ["""# @generated by package_lock.bzl from {package_lock}

load("@aspect_rules_js//js:npm_import.bzl", "npm_import")

"""]
    for project in projects:
        # print("%s -> %s" % (project['packageName'], project['projectFolder']))

        for (name, version) in settings['allPreferredVersions'].items():
            if name != project['packageName']:
                continue
            print("%s -> %s" % (name, version))

            if version == "workspace:*":
                version = "0.0.0"

            # if "resolved" not in dep.keys():
            #     continue
            deps = []
            # if "requires" in dep.keys():
            #     for n in dep["requires"].keys():
            #         deps.append("@" + _repo_name(n, [d["version"] for (p, d) in project["dependencies"].items() if p == n][0]))
            bzl_out.extend([_NPM_IMPORT_TMPL.format(
                name = _repo_name(name, version),
                package = name,
                version = version,
            )])
    return bzl_out

def _define_aliases(repository_ctx, lockfile):
    # The lockfile format refers to the context as the package with empty name.
    # This gives us a way to know which deps the user declared in their package.json
    # (the direct dependencies).
    direct = lockfile["packages"][""]
    direct_names = []
    direct_names.extend(direct.get("devDependencies", {}).keys())
    direct_names.extend(direct.get("dependencies", {}).keys())

    for (direct_name, direct_dep) in lockfile["dependencies"].items():
        if not direct_name in direct_names:
            continue
        direct_version = direct_dep["version"]
        if direct_dep["version"] == "workspace:*":
            direct_dep["version"] = "0.0.0"
        dep_build_content = """# @generated by translate_package_lock.bzl

alias(name = "{package}", actual = "{actual}", visibility = ["//visibility:public"])
""".format(
            package = direct_name.split("/")[-1],
            actual = "@" + _repo_name(direct_name, direct_dep["version"]),
        )
        repository_ctx.file(direct_name + "/BUILD.bazel", dep_build_content)

def _translate_rush_pnpm(repository_ctx):
    pnpm_content = json.decode(repository_ctx.read(repository_ctx.attr.pnpm_settings))
    rush_content = json.decode(repository_ctx.read(repository_ctx.attr.rush_config))
    projects = rush_content["projects"]

    repository_ctx.file("repositories.bzl", "\n".join(_parse_projects(projects, pnpm_content)))
    repository_ctx.file("BUILD.bazel", "")
    _define_aliases(repository_ctx, rush_content)

translate_rush_pnpm = struct(
    doc = _DOC,
    implementation = _translate_rush_pnpm,
    attrs = _ATTRS,
    repository_name = _repo_name,
    testonly_import_dependencies = _parse_projects,
    testonly_define_aliases = _define_aliases,
)
