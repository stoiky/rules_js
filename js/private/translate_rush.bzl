"Convert package-lock.json into starlark Bazel fetches"
load("@bazel_skylib//lib:paths.bzl", "paths")

_DOC = """
"""

_ATTRS = {
    "rush_config": attr.label(
        doc = "The location of rush config file or the output created by a target.",
        mandatory = True,
    ),
}

_NPM_IMPORT_TMPL = """    # @generated from [translate_rush_pnpm.bzl]
    rush_import(
        name = "{name}",
        package = "{package}",
        version = "{version}",
        integrity = "{integrity}", # temporarily used as the abs location
        deps = {deps},
    )
"""

def _user_workspace_root(repository_ctx):
    rush_config = repository_ctx.attr.rush_config
    segments = []
    if rush_config.package:
        segments.extend(rush_config.package.split("/"))
    segments.extend(rush_config.name.split("/"))
    segments.pop()
    user_workspace_root = repository_ctx.path(rush_config).dirname
    for i in segments:
        user_workspace_root = user_workspace_root.dirname
    return str(user_workspace_root)

def _escape(package_name):
    "Make a package name into a valid label without slash or at-sign"
    return package_name.replace("/", "_").replace("@", "_")

def _repo_name(package_name, version):
    "Make an external repository name from a package name and a version"
    return "npm_%s-%s" % (_escape(package_name), version)

def _import_dependencies(repository_ctx, rush_graph, bzl_out = None):
    # To allow recursion, accept an optional accumulator
    # If it's not present, we need to start with the header of the file
    bzl_out = bzl_out or ["""# @generated by translate_rush.bzl
load("@aspect_rules_js//js:rush_import.bzl", "rush_import")

def npm_repositories():
    "Define internal repositories to symlink them back to where they reside."
"""]
    for (name, info) in rush_graph.items():
        deps = []
        for dep in info['dependencies']:
            deps.append("@" + _repo_name(dep, "0.0.0"))
        bzl_out.extend([_NPM_IMPORT_TMPL.format(
            name = _repo_name(name, "0.0.0"),
            package = name,
            version = "0.0.0",
            integrity = paths.join(_user_workspace_root(repository_ctx), info['relativePath']),
            deps = deps,
        )])

    return bzl_out

def _define_aliases(repository_ctx, rush_graph):
    for (name, info) in rush_graph.items():
        for dep in info['dependencies']:
            # Generate alias of direct dependency
            dep_build_content = """# @generated by translate_rush.bzl

alias(name = "{package}", actual = "{actual}", visibility = ["//visibility:public"])
            """.format(
                package = name.split("/")[-1],
                actual = "@" + _repo_name(name, "0.0.0"),
            )
            repository_ctx.file(name + "/BUILD.bazel", dep_build_content)

def _translate_rush_impl(repository_ctx):
    rush_graph = json.decode(repository_ctx.read(repository_ctx.attr.rush_config))
    repository_ctx.file("repositories.bzl", "\n".join(_import_dependencies(repository_ctx, rush_graph)))
    repository_ctx.file("BUILD.bazel", "")
    _define_aliases(repository_ctx, rush_graph)

translate_rush = struct(
    doc = _DOC,
    implementation = _translate_rush_impl,
    attrs = _ATTRS,
    repository_name = _repo_name,
    testonly_import_dependencies = _import_dependencies,
    testonly_define_aliases = _define_aliases,
)
