"Convert package-lock.json into starlark Bazel fetches"
load("@bazel_skylib//lib:paths.bzl", "paths")

_DOC = """
"""

_ATTRS = {
    "pnpm_lock": attr.label(
        doc = "The location of rush config file or the output created by a target.",
        mandatory = True,
    ),
}

_NPM_IMPORT_TMPL = """    # @generated from [translate_rush.bzl]
    rush_import(
        name = "{name}",
        package = "{package}",
        version = "{version}",
        integrity = "{integrity}",
        deps = {deps},
    )
"""

def _user_workspace_root(repository_ctx):
    pnpm_lock = repository_ctx.attr.pnpm_lock
    segments = []
    if pnpm_lock.package:
        segments.extend(pnpm_lock.package.split("/"))
    segments.extend(pnpm_lock.name.split("/"))
    segments.pop()
    user_workspace_root = repository_ctx.path(pnpm_lock).dirname
    for i in segments:
        user_workspace_root = user_workspace_root.dirname
    return str(user_workspace_root)

def _ensure_not_link_version(version):
    if version.find("link:../") > -1:
        return "workspace"
    return version

def _get_local_package(repository_ctx, project_path):
    keys_to_extract = ["name", "version"]
    path = paths.join(_user_workspace_root(repository_ctx), project_path, "package.json")
    package_json = json.decode(repository_ctx.read(path))
    return { key: package_json[key] for key in keys_to_extract }

def _escape(package_name):
    "Make a package name into a valid label without slash or at-sign"
    return package_name.replace("/", "_").replace("@", "_").replace("+", "-").replace("~", "_").replace("^", "_")

def _repo_name(package_name, version):
    "Make an external repository name from a package name and a version"
    return "npm_%s-%s" % (_escape(package_name), _escape(version))

def _import_dependencies(repository_ctx, pnpm_lock, bzl_out = None):
    # To allow recursion, accept an optional accumulator
    # If it's not present, we need to start with the header of the file
    bzl_out = bzl_out or ["""# @generated by translate_rush.bzl
load("@aspect_rules_js//js:rush_import.bzl", "rush_import")

def npm_repositories():
    "Define internal repositories to symlink them back to where they reside."
"""]
    packages = []
    external_deps = []
    for (importer_name, importer_info) in pnpm_lock["importers"].items():
        if (importer_name == "."):
            continue
        packages.append(importer_name)
        project_path = importer_name.removeprefix("../../")
        project_package = _get_local_package(repository_ctx, project_path)
        project_name = project_package["name"]
        project_version = "workspace" # temporary
        # print("Project: %s - %s" % (project_name, project_version))
        deps = []
        if 'devDependencies' in importer_info:
            for (dep_name, dep_version) in importer_info['devDependencies'].items():
                deps.append("@" + _repo_name(dep_name, _ensure_not_link_version(dep_version)))
        if 'dependencies' in importer_info:
            for (dep_name, dep_version) in importer_info['dependencies'].items():
                deps.append("@" + _repo_name(dep_name, _ensure_not_link_version(dep_version)))
        # if 'optionalDependencies' in importer_info:
        #     for (dep_name, dep_version) in importer_info['optionalDependencies'].items():
        #         deps.append("@" + _repo_name(dep_name, _ensure_not_link_version(dep_version)))

        bzl_out.extend([_NPM_IMPORT_TMPL.format(
            name = _repo_name(project_name, project_version),
            package = project_name,
            version = project_version,
            integrity = paths.join(_user_workspace_root(repository_ctx), project_path),
            deps = deps,
        )])

    if len(packages) != 157:
        print(len(packages))
        # fail("not enough packages")

    for (dep_name, dep_info) in pnpm_lock["packages"].items():
        external_deps.append(dep_name)
        dep_version = dep_name.rpartition("/")[2] # the last part of a dep is the version
        name = dep_name[1:].rpartition("/")[0] # these packages always begin with `/`
        path = "%s@%s" % (name.replace("/", "+"), dep_version)
        deps = []
        if 'dependencies' in dep_info:
            for (n, v) in dep_info["dependencies"].items():
                deps.append("@" + _repo_name(n, v))
        bzl_out.extend([_NPM_IMPORT_TMPL.format(
            name = _repo_name(name, dep_version),
            package = path,
            version = dep_version,
            integrity = paths.join(_user_workspace_root(repository_ctx), "common", "temp", "node_modules", ".pnpm", path),
            deps = deps,
        )])

    if len(external_deps) != 3700:
        print(len(external_deps))
        # fail("not enough external deps")

    return bzl_out


def _write_alias(repository_ctx, name, version):
    dep_build_content = """# @generated

alias(name = "{package}", actual = "{actual}", visibility = ["//visibility:public"])
""".format(
        package = name.split("/")[-1],
        actual = "@" + _repo_name(name, _ensure_not_link_version(version)),
    )
    repository_ctx.file(name + "/BUILD.bazel", dep_build_content)

def _define_aliases(repository_ctx, pnpm_lock):
    for (importer_name, importer_info) in pnpm_lock["importers"].items():
        if (importer_name == "."):
            continue
        project_package = _get_local_package(repository_ctx, importer_name.removeprefix("../../"))
        project_name = project_package["name"]
        _write_alias(repository_ctx, project_name, "workspace")

    for (dep_name, dep_info) in pnpm_lock["packages"].items():
        dep_version = dep_name.rpartition("/")[2] # the last part of a dep is the version
        name = dep_name[1:].rpartition("/")[0] # these packages always begin with `/`
        path = "%s@%s" % (name.replace("/", "+"), dep_version)
        _write_alias(repository_ctx, name, dep_version)
        # if 'dependencies' in importer_info:
        #     for (dep_name, dep_version) in importer_info['dependencies'].items():
        #         _write_alias(repository_ctx, dep_name, dep_version)
        # if 'devDependencies' in importer_info:
        #     for (dep_name, dep_version) in importer_info['devDependencies'].items():
        #         _write_alias(repository_ctx, dep_name, dep_version)

def _translate_rush_impl(repository_ctx):
    pnpm_lock = json.decode(repository_ctx.read(repository_ctx.attr.pnpm_lock))
    repository_ctx.file("repositories.bzl", "\n".join(_import_dependencies(repository_ctx, pnpm_lock)))
    repository_ctx.file("BUILD.bazel", "")
    _define_aliases(repository_ctx, pnpm_lock)

translate_rush = struct(
    doc = _DOC,
    implementation = _translate_rush_impl,
    attrs = _ATTRS,
    repository_name = _repo_name,
    testonly_import_dependencies = _import_dependencies,
    testonly_define_aliases = _define_aliases,
)
